import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import lib.StdRandom;
import lib.StdDraw;
import lib.Stopwatch;

/*
 * The “beck” exploit. A popular web server supports a function named
no2slash() whose purpose is to collapse multiple / characters. For example, the
string /d1///d2////d3/test.html collapses to /d1/d2/d3/test.html. The orig-
inal algorithm was to repeatedly search for a / and copy the remainder of the string:

int n = name.length();
int i = 1;
while (i < n)
{
if ((c[i-1] == '/') && (c[i] == '/'))
{
for(int j = i+1; j < n; j++)
c[j-1] = c[j];
n--;
}
else i++;
}

Unfortunately, this code can takes quadratic time (for example, if the string con-
sists of the / character repeated n times). By sending multiple simultaneous re-
quests with large numbers of / characters, a hacker could deluge the server and
starve other processes for CPU time, thereby creating a denial-of-service attack.
Develop a version of no2slash() that runs in linear time and does not allow for
this type of attack.
 */

public class BeckExploit {
    private static final Pattern MULTIPLE_SLASHES = Pattern.compile("/{2,}");

    public static String no2slashManual(String name) {
        if (name == null || name.isEmpty()) {
            return name;
        }

        StringBuilder result = new StringBuilder(name.length());
        boolean lastWasSlash = false;

        for (int i = 0; i < name.length(); i++) {
            char c = name.charAt(i);
            if (c == '/') {
                if (!lastWasSlash) {
                    result.append(c);
                    lastWasSlash = true;
                }
            } else {
                result.append(c);
                lastWasSlash = false;
            }
        }

        return result.toString();
    }

    public static String no2slashRegex(String name) {
        if (name == null || name.isEmpty()) {
            return name;
        }
        return MULTIPLE_SLASHES.matcher(name).replaceAll("/");
    }

    public static String generateTestString(int length) {
        StringBuilder sb = new StringBuilder(length);
        int consecutiveSlashes = 0;
        
        for (int i = 0; i < length; i++) {
            if (StdRandom.uniformDouble() < 0.4 || consecutiveSlashes > 0) {
                sb.append('/');
                if (consecutiveSlashes < 3 && StdRandom.uniformDouble() < 0.7) {
                    consecutiveSlashes++;
                } else {
                    consecutiveSlashes = 0;
                }
            } else {
                sb.append((char) (StdRandom.uniformInt(26) + 'a'));
                consecutiveSlashes = 0;
            }
        }
        
        return sb.toString();
    }

    public static void draw(List<Integer> inputSizes, List<Double> manualTimes, List<Double> regexTimes){
        StdDraw.setCanvasSize(800, 600);
        StdDraw.setXscale(0, 1000000);
        StdDraw.setYscale(0, Math.max(getMaxValue(manualTimes), getMaxValue(regexTimes)) * 1.1);

        StdDraw.setPenColor(StdDraw.RED);
        for (int i = 1; i < inputSizes.size(); i++) {
            StdDraw.line(inputSizes.get(i-1), manualTimes.get(i-1), inputSizes.get(i), manualTimes.get(i));
        }

        StdDraw.setPenColor(StdDraw.BLUE);
        for (int i = 1; i < inputSizes.size(); i++) {
            StdDraw.line(inputSizes.get(i-1), regexTimes.get(i-1), inputSizes.get(i), regexTimes.get(i));
        }
        
        StdDraw.show();
    }

    public static void main(String[] args) {
        List<Integer> inputSizes = new ArrayList<>();
        List<Double> manualTimes = new ArrayList<>();
        List<Double> regexTimes = new ArrayList<>();


        for (int size = 1000; size <= 1000000; size += 10000) {
            String testString = generateTestString(size);
            
            Stopwatch timer = new Stopwatch();
            no2slashManual(testString);
            double manualTime = timer.elapsedTime();

            Stopwatch timer2 = new Stopwatch();
            no2slashRegex(testString);
            double regexTime = timer2.elapsedTime();

            inputSizes.add(size);
            manualTimes.add(manualTime / 1_000_000); 
            regexTimes.add(regexTime / 1_000_000);
        }

       draw(inputSizes, manualTimes, regexTimes);

    }

    private static double getMaxValue(List<Double> list) {
        return list.stream().mapToDouble(Double::longValue).max().orElse(0);
    }
}

